---
title: "REACT(1)"
date: 2019-12-30 16:40:28
---

## 1. 배운 내용
### 리액트 시작
- 리액트는 View만 신경쓰는 라이브러리이다.<br>
- 리액트는 Virtual DOM을 사용하여 이전 내용과 현재 내용을 비교하고, 바뀐 부분만 실제 DOM에 적용한다.<br>
- create-react-app으로 간편하게 프로젝트 작업환경을 구축할 수 있다.<br><br>

### JSX
- JSX란 자바스크립트의 확장 문법이다. JSX를 통해 JI를 매우 편하게 렌더링할 수 있다.<br>
- 다음과 같은 규칙을 가진다.<br>
  1) 컴포넌트에 여러 요소가 있다면 반드시 부모 요소 하나로 감싸야 한다.<br>
  2) JSX 안에서는 자바스크립트 표현식을 작성할 수 있으며 해당 코드를 {}로 감싸면 된다.<br>
  3) JSX 내부의 자바스크립트 표현식에서는 if문을 쓸 수 없다. 따라서 조건부 연산자(삼항 연산자)를 사용하거나 JSX 밖에서 if문을 써야 한다.<br>
  4) DOM 요소에 스타일 적용 시 객체 형태로 넣어주어야 하며, 카멜 표기법을 따라야 한다.<br>
  5) class 대신 className으로 설정해야 한다.<br><br>
  
### 컴포넌트
- 클래스형 컴포넌트: state, 라이프사이클 기능, 임의 메서드 정의가 가능하다. render함수가 꼭 있어야 하고 그 안에서 보여줄 JSX를 반환한다.<br>
- 함수형 컴포넌트: 선언하기 편하고, 메모리 자원도 덜 사용한다. state와 라이프사이클 API를 사용할 수 없지만, Hooks로 대체할 수 있다.<br>
- props: 컴포넌트 속성을 설정할 때 사용하는 요소. props 값은 부모 컴포넌트에서 설정할 수 있으며, 자식 컴포넌트는 읽기 전용으로 받을 수 있다. children, 비구조화 할당 문법, propTypes에 대해서도 배움.<br>
- state: 컴포넌트 내부에서 배뀔 수 있는 값. 클래스형 컴포넌트는 state로, 함수형 컴포넌트는 useState라는 함수로 사용할 수 있다.<br>
- state 값을 바꿔야 할 때에는 setState 혹은 useState로부터 전달받은 세터 함수를 사용해야 한다. 배열이나 객체 업데이트 시에는 사본을 만들어야 한다.<br><br>

### 이벤트 핸들링
- input 값을 state에 넣고, onChange, onClick 함수에서 setState를 실행하는 이벤트 핸들링을 실습.<br>
- 여러개의 input 값을 관리할 때, 함수형 컴포넌트는 클래스형 컴포넌트와 달리, useState에서 form 객체를 사용할 수도 있다.<br><br>


### ref: DOM에 이름 달기
- ref는 DOM을 꼭 직접적으로 건드려야 할 때 사용한다. (예: 특정 input에 포커스 주기, 스크롤 박스 조작하기 등)<br>
- ref를 사용하는 방법은 2가지이다. 콜백함수를 통한 ref 설정과 createRef를 통한 ref 설정.<br>
- 리액트에서는 컴포넌트에 ref를 달 수도 있다.<br><br>

### 컴포넌트 반복
- 자바스크립트 배열 객체의 내장함수인 map()함수를 사용하여, 리액트 프로젝트에서 반복적인 내용을 효율적으로 보여주고 관리할 수 있다. map 함수를 통해 배열 내 각 요소를 원하는 규칙에 따라 변환한 후 그 결과로 새로운 배열을 생성한다.<br>
- map함수를 쓸 때에는 key 값을 설정해야 한다. key는 고유한 값이며, key를 통해 변화 감지를 더욱 효율적으로 할 수 있다.<br>
- 상태 안에서 배열을 변형할 때는, 배열에 직접 접근하지 않고, 배열 내장 함수를 사용하여 새로운 배열을 만든 후 이를 새로운 상태로 설정해주어야 한다.<br>
- 데이터 추가 기능시 concat 사용. 데이터 제거 기능시 filter 사용. 이 함수들을 통해 불변성 유지 할 수 있다.<br><br>

### 컴포넌트의 라이프사이클 메서드
- 라이프사이클 메서드는 컴포넌트 상태에 변화가 있을 때마다 실행하는 메서드이다.<br>
- 라이프사이클은 다음과 같이 나뉜다.<br>
  1) 마운트 (페이지에 컴포넌트가 나타날 때): constructor, getDerivedStateFromProps, render, componentDidMount<br>
  2) 업데이트 (컴포넌트 정보가 업데이트될 때): getDerivedStateFromProps, shouldComponentUpdate, render, getSnapshotBeforUpdate, componentDidUpdate<br>
  3) 언마운트 (페이지에서 컴포넌트가 사라질 때): componentWillUnmount<br><br>

### Hooks
- Hooks는 기존의 함수형 컴포넌트에서 할 수 없었던 다양한 작업들을 가능하게 한다.<br>
- useState: 함수형 컴포넌트에서도 상태 관리를 가능하게 해준다. useState는 여러 번 사용할 수도 있다.<br>
- useEffect: 컴포넌트가 렌더링될 때마다 특정 작업을 수행하도록 설정할 수 있는 Hook. useEffect의 두 번째 파라미터에 값을 넣음으로써, 마운트될 때만 혹은 특정 값이 업데이트될 때만 실행하게 만들 수도 있다.<br>
- useReducer: useState보다 더 다양한 컴포넌트 상황에 따라 다양한 상태를 다른 값으로 업데이트하고 싶을 때 사용하는 Hook. 컴포넌트 업데이트 로직을 컴포넌트 바깥으로 빼낼 수 있다는 장점이 있다.<br>
- useMemo: 함수형 컴포넌트 내부에서 발생하는 연산을 최적화할 수 있다. 렌더링하는 과정에서 특정 값이 바뀌었을 때만 연산을 실행하게 만들 수 있다.<br>
- useCallback: 이벤트 핸들러 함수를 필요할 때만 생성하게 하여, 렌더링 성능을 최적화할 수 있다.<br>
- useRef: 함수형 컴포넌트에서 ref를 쉽게 사용하도록 해준다.<br>
- custom hooks: hook들과 일반함수, 값을 조합해서 새로운 hook을 만들어내는 것. 여러 컴포넌트에서 비슷한 기능을 공유할 경우, 커스텀 훅을 만들어 로직을 재사용할 수 있다.<br><br>

<br><br>
## 2. 질문 공유와 해결
