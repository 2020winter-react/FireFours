# 2020년 1월 12일

## 1. 배운 내용

### 13. 리액트 라우터로 SPA 개발하기

1. SPA란 Single Page Application의 약어로 한 개의 페이지로 이루어진 애플리케이션을 의미한다. 최초로 html파일을 다운로드 받은 후, 그 이후엔 json 파일로 데이터만 업데이트하는 형식이다. 
정말 하나의 화면을 가진 것은 아니고 라우팅(Routing)을 통해 글보기, 글쓰기 창 등 여러 화면으로 이동할 수 있다. 
    - 여러 창을 가지는 규모가 큰 애플리케이션의 경우 자바스크립트 파일이 비대해질 수 있다는 문제가 있으나 이를 추후에 배울 코드 스플리팅을 통해 해결할 수 있다. 
1. SPA를 구현하기 위한 모듈로 `react-router`가 대표적으로 이를 `yarn add react-router-dom`으로 설치한다. 그런 후 전체 `<App />`을 `<BrowserRouter>`로 감싸준다.
2. 가장 중요한 컴포넌트는 `<Route path={["/경로명", "/경로명2"]} component={컴포넌트이름}/>` 으로 경로와 해당 경로에 맞는 컴포넌트를 보여준다. 그리고 이와 같이 Route와 연결된 컴포넌트는 `match`, `location`, `history` 세가지 `props`을 기본적으로 받게 된다.
3. `<Link to="/경로명">링크 이름</Link>`은 해당 경로로 갈 수 있도록 해주는 링크를 생성한다.
4. `<Switch>...</Switch>` 컴포넌트는 여러 `<Route>`를 감싼 후 링크와 일치하는 단 하나의 컴포넌트만을 보여준다. 만약 설정하지 않는다면 조건에 충족하는 모든 컴포넌트가 보여지게 된다.
5. URL 파라미터 받는 법: `<Route path='경로명/:파라미터' component={컴포넌트이름}/>` 에서 처럼 `:`으로 파라미터임을 선언할 수 있다. 컴포넌트에선 `props.match.params.파라미터이름`으로 해당 파라미터에 접근하여 값을 불러올 수 있다.
6. Query 받는 법: 쿼리는 props로 넘어오는 값 중 `location`의 `search`에서 값을 찾을 수 있다. 이때 `qs`란 모듈을 이용하면 좀 더 편하게 쿼리를 오브젝트로 변환할 수 있다.

**부가 기능**

1. history: history.goBack(), history.push() 등을 통해 뒤로가기, 홈으로 이동을 구현할 수 있다. history.block('정말 떠나시나요') 로 페이지 변화 발생시 경고 메시지 생성도 가능하다.
2. withRouter: route와 연결되지 않은 컴포넌트여도 `match`, `location`, `history` 등을 받을 수 있도록 해주는 HoC이다.
3. NavLink: Link의 Nav용으로 해당 링크에 맞게 CSS를 토글할 수 있다.

### 14. 외부 API를 연동하여 뉴스 뷰어 만들기

1. 비동기 작업의 이해: 웹브라우저는 API 호출과 같은 시간이 걸리는 작업을 비동기로 처리한다. 즉 실행의 결과를 기다리지 않는다. 
결과를 기다려야 하는 경우 콜백, Promise, Async/Await을 통해 결과를 받은 뒤 작업을 진행시킬 수 있다.
2. axios로 API 호출해서 데이터 받아오기: axios는 비동기 HTTP 클라이언트 모듈로 `const result  = await axios.get(url, params)` 와 같은 형태로 사용할 수 있다. 
3. 데이터 연동하기: 이때 주의할 점은 useEffect 함수 자체를 async화 시키는 것이 아닌 따로 `const fetchData = async () => {}`와 같이 데이터를 호출하기 위한 비동기 함수를 생성해주어야 한다. 이는 useEffect를 사용하기 위한 원칙으로 꼭 주의해야한다.
1. usePromise 커스텀 Hook 만들기: 비동기 함수를 인자로 받아, loading, resolved, error 를 반환하는 hook을 만들어보았다.


### 15. Conetxt API

1. Context API의 전역 상태 관리 흐름: 기존 리액트에선 탑다운 방식의 여러 컴포넌트를 거칠 수 밖에 없는 상태 흐름을 가지고 있다. 전역적인 상태를 더 효율적으로 관리하기 위해 Context API가 나왔고, 원하는 값을 여러 컴포넌트 거치지 않고 한번에 가져올 수 있게 되었다.
2. 사용법 익히기
   1. `const SampleContext = createContext(나만의 상태)`를 통해 상태를 생성한다. 이렇게 생성된 Context는 `Value`, `Consumer`, `Provider`를 가진다.
   2. `<SampleContext.Provider value={초기값}>...</SampleContext.Provider>` 처럼 Provider를 사용할 땐 **반드시 Value를 설정** 해주어야 한다.
3. 동적 Context 사용하기
   1. 동적으로 사용한다는 건 Context를 변화시킬 수도 있게 하는 것이다. 여러 방법이 있지만 교재에선 Hook을 이용하여 Context 속에 state를 수정할 수 있는 함수를 함께 넣었다. 
   ```jsx
    const SampleContext = createContext({state: 2, action: setNum: ()=>{}});

    const SampleProvider = ({children}) => {
        const [num, setNum] = useState(9);
        const value = {state: num, actions: setNum};
        return <SampleContext.Provider value={value}></SampleContext.Provider>
    }
   const { Consumer: SampleConsumer } = SampleContext;
   export { SampleProvider, SampleConsumer }
   ```
   2. 위와 같이 Provider와 Consumer를 분리하여 더 편리하게 상태를 관리할 수 있도록 하였다.
4. Consumer 대안법: 하지만 이런 식으로 Consumer를 그때 그때 불러서 사용하는 것 보다 리액트에서 기본적으로 더 편리한 기능을 제공한다. 
   1. useContext Hook: 함수형 컴포넌트에서 사용 가능
   2. static contextType: 클래스형 컴포넌트에서 사용 가능


### 16. 리덕스 라이브러리 이해하기

1. 개념 정리
   1. 액션(Action)
   2. 액션 생성 함수
   3. 리듀서(Reducer)
   4. 스토어(Store)
   5. 디스패치(Dispatch)
   6. 구독(Subscribe)
2. 3가지 규칙
   1. 단일 스토어
   2. 일기 전용 상태
   3. 리듀서는 순수한 함수


### 17. 리덕스를 이용한 리액트 상태 관리


## 2. Q&A
### 질문:

App.js에 렌더링된 CounterContainer 컴포넌트에서, number를 state.counter.number와 같이 쓸 수 있는 이유는?

```javascript
// containers/CounterContainer.js

const mapStateToProps = state => ({
  number: state.counter.number
});
```

### 해결:

(1)

```javascript
const mapStateToProps = state => ({
  number: state.counter.number
});
```

mapStateToProps는 state를 파라미터로 받아오며, 이 값은 <b>'현재 스토어가 지니고 있는 상태'</b>를 가리킨다.

(2)
리듀서인 counter와 todos를 묶은 rootReducer를 사용해서 store를 생성했다.
react-redux에서 제공하는 Provider컴포넌트로 App 컴포넌트를 감싸면(이때 store를 props로 전달해주어야 함), 리액트 컴포넌트에서 스토어를 사용할 수 있다.

```javascript
const store = createStore(rootReducer);

ReactDOM.render(
  <Provider store={store}>
    <App />
  </Provider>,
  document.getElementById("root")
);
```

(3)
(2)를 통해 리액트 컴포넌트에서 스토어 사용이 가능해지므로, 현재 스토어가 지니고 있는 상태인 state에도 접근할 수 있고, 스토어 내의 리듀서(여기서는 counter)에도 접근할 수 있으며, counter 리듀서 내의 number에 접근할 수 있는 것이다. 
따라서 state.counter.number로 쓸 수 있다.

<hr />

### 질문: ColorProvider를 쓸 때의 이점은?

### 해결:

```javascript
<ColorContext.Provider value={{ color: 'black' }}>
```

기존에는 위와 같은 식으로 코드를 썼는데, 이와 달리 ColorProvider를 쓰면 하단의 코드와 같다.

```javascript
//App.js

  return (
    <ColorProvider>
        <ColorBox />
    </ColorProvider>
  );
}
```

```javascript
//contexts/color.js

const ColorProvider = ({ children }) => {
  const [color, setColor] = useState("black");
  const [subColor, setSubColor] = useState("red");

  const value = {
    state: { color, subColor },
    actions: { setColor, setSubColor }
  };

  return (
    <ColorContext.Provider value={value}>{children}</ColorContext.Provider>
  );
};
```
ColorProvider를 썼을 때의 이점은 다음과 같다.
1) App.js에서 사용되는 코드가 깔끔해진다.
2) <ColorContext.Provider>에서는 변화시킬 value을 props로 직접 주었는데, ColorProvider에서는 변화시킬 값을 따로 관리할 수 있다. 이렇게 value를 props로 직접 전달하지 않고 따로 관리함으로써, context의 value에 상태값 뿐만 아니라 동적인 함수도 용이하게 전달해줄 수 있다. 또한 value를 state와 actions로 나누어 관리할 수 있다는 점도 ColorProvider의 장점이다. 나누어 관리하는 것은 필수사항은 아니지만 이후 편리한 context값 사용을 위해 해놓는 것이 좋다.

<hr />

