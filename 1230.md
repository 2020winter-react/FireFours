---
title: "12/30 공부"
date: 2019-12-30 16:40:28
---

## 1. 배운 내용
### 리액트 시작
- 리액트는 View만 신경쓰는 라이브러리이다.<br>
- 리액트는 Virtual DOM을 사용하여 이전 내용과 현재 내용을 비교하고, 바뀐 부분만 실제 DOM에 적용한다.<br>
- create-react-app으로 간편하게 프로젝트 작업환경을 구축할 수 있다.<br><br>

### JSX
- JSX란 자바스크립트의 확장 문법이다. JSX를 통해 JI를 매우 편하게 렌더링할 수 있다.<br>
- 다음과 같은 규칙을 가진다.<br>
  1) 컴포넌트에 여러 요소가 있다면 반드시 부모 요소 하나로 감싸야 한다.<br>
  2) JSX 안에서는 자바스크립트 표현식을 작성할 수 있으며 해당 코드를 {}로 감싸면 된다.<br>
  3) JSX 내부의 자바스크립트 표현식에서는 if문을 쓸 수 없다. 따라서 조건부 연산자(삼항 연산자)를 사용하거나 JSX 밖에서 if문을 써야 한다.<br>
  4) DOM 요소에 스타일 적용 시 객체 형태로 넣어주어야 하며, 카멜 표기법을 따라야 한다.<br>
  5) class 대신 className으로 설정해야 한다.<br><br>
  
### 컴포넌트
- 클래스형 컴포넌트: state, 라이프사이클 기능, 임의 메서드 정의가 가능하다. render함수가 꼭 있어야 하고 그 안에서 보여줄 JSX를 반환한다.<br>
- 함수형 컴포넌트: 선언하기 편하고, 메모리 자원도 덜 사용한다. state와 라이프사이클 API를 사용할 수 없지만, Hooks로 대체할 수 있다.<br>
- props: 컴포넌트 속성을 설정할 때 사용하는 요소. props 값은 부모 컴포넌트에서 설정할 수 있으며, 자식 컴포넌트는 읽기 전용으로 받을 수 있다. children, 비구조화 할당 문법, propTypes에 대해서도 배움.<br>
- state: 컴포넌트 내부에서 배뀔 수 있는 값. 클래스형 컴포넌트는 state로, 함수형 컴포넌트는 useState라는 함수로 사용할 수 있다.<br>
- state 값을 바꿔야 할 때에는 setState 혹은 useState로부터 전달받은 세터 함수를 사용해야 한다. 배열이나 객체 업데이트 시에는 사본을 만들어야 한다.<br><br>

### 이벤트 핸들링
- input 값을 state에 넣고, onChange, onClick 함수에서 setState를 실행하는 이벤트 핸들링을 실습.<br>
- 여러개의 input 값을 관리할 때, 함수형 컴포넌트는 클래스형 컴포넌트와 달리, useState에서 form 객체를 사용할 수도 있다.<br><br>


### ref: DOM에 이름 달기
- ref는 DOM을 꼭 직접적으로 건드려야 할 때 사용한다. (예: 특정 input에 포커스 주기, 스크롤 박스 조작하기 등)<br>
- ref를 사용하는 방법은 2가지이다. 콜백함수를 통한 ref 설정과 createRef를 통한 ref 설정.<br>
- 리액트에서는 컴포넌트에 ref를 달 수도 있다.<br><br>

### 컴포넌트 반복
- 자바스크립트 배열 객체의 내장함수인 map()함수를 사용하여, 리액트 프로젝트에서 반복적인 내용을 효율적으로 보여주고 관리할 수 있다. map 함수를 통해 배열 내 각 요소를 원하는 규칙에 따라 변환한 후 그 결과로 새로운 배열을 생성한다.<br>
- map함수를 쓸 때에는 key 값을 설정해야 한다. key는 고유한 값이며, key를 통해 변화 감지를 더욱 효율적으로 할 수 있다.<br>
- 상태 안에서 배열을 변형할 때는, 배열에 직접 접근하지 않고, 배열 내장 함수를 사용하여 새로운 배열을 만든 후 이를 새로운 상태로 설정해주어야 한다.<br>
- 데이터 추가 기능시 concat 사용. 데이터 제거 기능시 filter 사용. 이 함수들을 통해 불변성 유지 할 수 있다.<br><br>

### 컴포넌트의 라이프사이클 메서드
- 라이프사이클 메서드는 컴포넌트 상태에 변화가 있을 때마다 실행하는 메서드이다.<br>
- 라이프사이클은 다음과 같이 나뉜다.<br>
  1) 마운트 (페이지에 컴포넌트가 나타날 때): constructor, getDerivedStateFromProps, render, componentDidMount<br>
  2) 업데이트 (컴포넌트 정보가 업데이트될 때): getDerivedStateFromProps, shouldComponentUpdate, render, getSnapshotBeforUpdate, componentDidUpdate<br>
  3) 언마운트 (페이지에서 컴포넌트가 사라질 때): componentWillUnmount<br><br>

### Hooks
- Hooks는 기존의 함수형 컴포넌트에서 할 수 없었던 다양한 작업들을 가능하게 한다.<br>
- useState: 함수형 컴포넌트에서도 상태 관리를 가능하게 해준다. useState는 여러 번 사용할 수도 있다.<br>
- useEffect: 컴포넌트가 렌더링될 때마다 특정 작업을 수행하도록 설정할 수 있는 Hook. useEffect의 두 번째 파라미터에 값을 넣음으로써, 마운트될 때만 혹은 특정 값이 업데이트될 때만 실행하게 만들 수도 있다.<br>
- useReducer: useState보다 더 다양한 컴포넌트 상황에 따라 다양한 상태를 다른 값으로 업데이트하고 싶을 때 사용하는 Hook. 컴포넌트 업데이트 로직을 컴포넌트 바깥으로 빼낼 수 있다는 장점이 있다.<br>
- useMemo: 함수형 컴포넌트 내부에서 발생하는 연산을 최적화할 수 있다. 렌더링하는 과정에서 특정 값이 바뀌었을 때만 연산을 실행하게 만들 수 있다.<br>
- useCallback: 이벤트 핸들러 함수를 필요할 때만 생성하게 하여, 렌더링 성능을 최적화할 수 있다.<br>
- useRef: 함수형 컴포넌트에서 ref를 쉽게 사용하도록 해준다.<br>
- custom hooks: hook들과 일반함수, 값을 조합해서 새로운 hook을 만들어내는 것. 여러 컴포넌트에서 비슷한 기능을 공유할 경우, 커스텀 훅을 만들어 로직을 재사용할 수 있다.<br><br>

<br><br>
## 2. 질문 공유와 해결
##useRef()
###-일반적인 사용방법
useRef() Hook은 함수형 컴포넌트에서 ref를 쉽게 사용할 수 있도록 해주는 용도로 사용한다. 
이 메서드를 사용하는 방법은 다음과 같다. 
```javascript
 const ref = useRef(initialValue)
```
useRef는 .current 프로퍼티로 전달된 인자로 초기화된 변경 가능한 ref객체를 반환한다. 

일반적인 사용용도는
```javascript
 function TextInputWithFocusButton() {
  const inputEl = useRef(null);
  const onButtonClick = () => {
    // `current` points to the mounted text input element
    inputEl.current.focus();
  };
  return (
    <>
      <input ref={inputEl} type="text" />
      <button onClick={onButtonClick}>Focus the input</button>
    </>
  );
}
 
```
와 같이 DOM의 특정 Element를 참조를 저장하기 위해 사용한다. 

위 코드에서 
```javascript
 <input ref={inputEl} type="text" />
```
를 실행하게 되면 input.current에는 input객체의 참조가 할당된다. 따라서 
```javascript
 input.current.something()
```
과 같이 해당 DOM element에 접근 해줄 수 있는 것이다. 

###-다른 사용 방법

useRef()는 컴포넌트 내에서 로컬변수를 사용해야 할 때도 사용된다.

사용예를 보자면 

```javascript
import React,{useRef} from 'react';

const RefSample=()=>{
    const id=useRef(1);
    const setId=(n)=>{
        id.current=n;
    }
    const printId=()=>{
        console.log(id.current);
    }
    return(
        <div>
        refSample
        </div>
    );
};

export default RefSample
```
이렇게 코드를 작성하면 
```javascript
const id=useRef(1);
```
이렇게 초기화된 useRef의 파라메터1은 id.current에 할당된다.

이렇게 할당된 값은 2가지 특징을 가진다.
1. 해당컴포넌트가 업데이트 되어도 값을 유지(full LifeTime)
2. 해당값을 변경해도 컴포넌트가 다시 렌더링되지 않는다.

이러한 특징 때문에 컴포넌트 내부에서 컴포넌트가 재 랜더링이 되어도 컴포넌트의 모든 lifetime 동안 지속적으로 값을 유지하고 있는 변수로서 사용하기도 한다.

##### Q:
여기서 한가지 의문이 생길 수 있다.
컴포넌트 내부에서 
 ```javascript
import React,{useRef} from 'react';

const RefSample=()=>{
    let id=1;//이부분을 유심히 보자.
    const setId=(n)=>{
        id.current=n;
    }
    const printId=()=>{
        console.log(id.current);
    }
    return(
        <div>
        refSample
        </div>
    );
};

export default RefSample
```
과 같이 일반 let 변수를 이용해서 로컬변수를 이용하면 안되는 것인가?

##### A:
그냥, '로컬변수'를 이용할 것이라면 상관이 없다. 하지만 let을 이용해 로컬변수를 설정해줄 경우 컴포넌트가 다시 렌더링 될 때 마다 let id=1;
이 실행되기 때문에 id값은 항상 1이 될 것이다. 하지만 위에서 설명했듯이 useRef()를 이용해 값을 초기화 해줄경우 .current에 할당된 값은 해당 컴포넌트가 unmount될때 까지 유지때문에 해당 변수에 동적으로 업데이트 해준 값을  유지해줄 수 있다.


<hr />

